using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Threading;
using UnityEngine;

namespace Incredulous.Twitch
{

    internal partial class TwitchConnection
    {
        public TwitchConnection(TwitchIRC twitchIRC)
        {
            tcpClient = new TcpClient(twitchIRC.ircAddress, twitchIRC.port);
            twitchCredentials = twitchIRC.twitchCredentials;
            clientUserTags = twitchIRC.clientUserTags;

            readBufferSize = twitchIRC.readBufferSize;
            readInterval = twitchIRC.readInterval;
            writeInterval = twitchIRC.writeInterval;

            debugIRC = twitchIRC.debugIRC;
        }

        /// <summary>
        /// The TCP Client instance for this connection.
        /// </summary>
        public TcpClient tcpClient { get; private set; }

        /// <summary>
        /// The queue of received messages from Twitch.
        /// </summary>
        public ConcurrentQueue<Chatter> chatterQueue { get; private set; } = new ConcurrentQueue<Chatter>();

        /// <summary>
        /// The queue of connection alerts generated by the various threads.
        /// </summary>
        public ConcurrentQueue<ConnectionAlert> connectionAlertQueue { get; private set; } = new ConcurrentQueue<ConnectionAlert>();

        /// <summary>
        /// The client user's Twitch tags.
        /// </summary>
        public IRCTags clientUserTags
        {
            get => _clientUserTags;
            private set => Interlocked.Exchange(ref _clientUserTags, value);
        }
        private IRCTags _clientUserTags;

        /// <summary>
        /// The status of the connection to Twitch.
        /// </summary>
        public ConnectionStatus status
        {
            get => (ConnectionStatus)_status;
            private set => Interlocked.Exchange(ref _status, (int)value);
        }
        private int _status;

        /// <summary>
        /// Whether there are any active threads in this connection.
        /// </summary>
        public bool threadsActive => (receiveThread?.IsAlive ?? false) || (sendThread?.IsAlive ?? false) || (connectionThread?.IsAlive ?? false);

        private readonly TwitchCredentials twitchCredentials;
        private readonly int readBufferSize;
        private readonly int readInterval;
        private readonly int writeInterval;
        private readonly bool debugIRC;

        private Thread sendThread;
        private Thread receiveThread;
        private Thread connectionThread;

        private bool continueThreads
        {
            get => _continueThreads == 1;
            set => Interlocked.Exchange(ref _continueThreads, value ? 1 : 0);
        }
        private int _continueThreads = 1;

        /// <summary>
        /// Initalizes a connection to Twitch and starts the send, receive, and check connection threads.
        /// </summary>
        public void Begin()
        {
            receiveThread = new Thread(() => ReceiveProcess());
            sendThread = new Thread(() => SendProcess());
            connectionThread = new Thread(() => CheckConnectionProcess());

            receiveThread.Start();
            sendThread.Start();
            connectionThread.Start();

            // Queue login commands
            SendCommand("PASS oauth:" + twitchCredentials.oauth.ToLower(), true);
            SendCommand("NICK " + twitchCredentials.username.ToLower(), true);
            SendCommand("CAP REQ :twitch.tv/tags twitch.tv/commands", true);
        }

        /// <summary>
        /// Instructs the connection threads to stop. Once <b>threadsActive</b> returns false, call the <b>Close</b> method to terminate the connection to Twitch.
        /// </summary>
        public void End()
        {
            status = ConnectionStatus.DisconnectionPending;
            continueThreads = false;
        }

        /// <summary>
        /// Terminates the connection to Twitch. <b>Note:</b> This method should only be called once all threads have terminated.
        /// </summary>
        public void Close()
        {
            if (continueThreads)
            {
                Debug.LogError("A TwitchConnection was instructed to close before its threads were terminated. Blocking the main thread to close the connection...");
                BlockingEndAndClose();
            }
            else
            {
                tcpClient.Close();
                status = ConnectionStatus.Disconnected;
            }
        }

        /// <summary>
        /// Terminates the connection to Twitch and blocks the main thread while the send, receive, and check connection threads end.
        /// </summary>
        public void BlockingEndAndClose()
        {
            status = ConnectionStatus.DisconnectionPending;
            continueThreads = false;
            receiveThread?.Join();
            sendThread?.Join();
            connectionThread?.Join();
            tcpClient.Close();
            status = ConnectionStatus.Disconnected;
        }
    }

}